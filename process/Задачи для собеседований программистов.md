# Задачи для собеседований программистов

### 1. Классическая задача
>Есть две переменные: a=5, b=3. 
>Поменяйте местами значения переменных без объявления третьей переменной.
    
* Решение:
    ```bsl
    а = 5;
    б = 3;

    // = 8
    а = б + а;

    // = 5
    б = а - б;

    // = 3
    а = а - б;
    ```



### 2. Поиск и исправление ошибок
>Исправить ошибки форматирования

>Исправить логические ошибки

>Точка входа - НайтиСсылкиПоНаименованию (вызываем эту функцию из внешнего участка кода с мСтроки = Массив, содержащий значения типа Строка - наименования товаров, ссылки на которые мы ищем)

```bsl
Функция НайтиСсылкиПоНаименованию(мСтроки) Экспорт
мСсылки = Новый 		Массив();
						Для Каждого мСтрока Из мСтроки 
			Цикл
мСсылки.Добавить(
	НайтиТовар(мСтрока)
	);
	КонецЦикла;

Возврат мСсылки;
КонецПроцедуры

Функция НайтиТовар(Наименование)
	Запрос = Новый Запрос("ВЫБРАТЬ Ссылка, Наименование ИЗ Справочник.Номенклатура ГДЕ НЕ ПометкаУдаления");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если СокрЛП(ВРег(Выборка.Наименование)) = ВРег(Наименование) Тогда
			Возврат Выборка.Ссылка;
		КонецЕсли;
	КонецЦикла;
КонецФункции
```

* Решение:
    >Исправить форматирование процедуры НайтиСсылкиПоНаименованию()

    >Перенести массив мСтроки в запрос через ВТ и фильтроваться соединением

    >Заполнять массив мСсылки из Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка")



### 3. Проверка знания математической логики и внимательности
>Какое значение вернет функция ВернутьЗначениеПараметра()?
>Почему?

>Вопрос со звёздочкой: как изменить код, чтобы функция возвращала 1?

```bsl
Функция ВернутьЗначениеПараметра()
	Параметр = 1;
	Если Функция1(Параметр) И Функция2(Параметр) Или Функция3(Параметр) Тогда
		Параметр = Параметр + 1000;
	КонецЕсли;

	Возврат Параметр;
КонецФункции

Функция Функция1(Параметр)
	Параметр = Параметр + 1;
	
	Возврат Ложь;
КонецФункции

Функция Функция2(Параметр)
	Параметр = Параметр + 10;
	
	Возврат Ложь;
КонецФункции

Функция Функция3(Параметр)
	Параметр = Параметр + 100;
	
	Возврат Ложь;
КонецФункции
```

* Решение:
    >Ответ: 102
    
    >Функция2() не будет вычислена, т.к. Функция1() вернула Ложь
    
    >Функция3() будет вычислена, т.к. Функция1() И Функция2() вернуло Ложь
    
    >\+ 1000 не будет вычислено, т.к. общее условие = Ложь

    >Вопрос со звёздочкой: добавить Знач в объявление параметров функций, т.к. при изменении значения параметров функций, их значение меняется и в месте, которое их вызвало, если не было написано Знач



### 4. Работа с транзакциями
>Какой будет итог выполнения представленного алгоритма, запущенного вызовом процедуры main()?
>Как исправить ошибку?

```bsl
Процедура main()
	НачатьТранзакцию();
	Попытка                                                                                             
		НачатьТранзакцию();
		Ссылка = Справочники.Контрагенты.ПолучитьСсылку(Новый УникальныйИдентификатор);		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Ссылка", Ссылка);
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1 
		|	Ссылка
		|ИЗ 
		|	Справочник.Контрагенты
		|ГДЕ
		|	Ссылка = &Ссылка"
		
		Запрос.Выполнить();
		
		ПроцедураСВызовомИсключенияВПопытке();
		
		ОтменитьТранзакцию();
		
		НовыйКонтрагент = Справочники.Контрагенты.СоздатьЭлемент();
		НовыйКонтрагент.Наименование = СокрЛП(ТекущаяДата());
		НовыйКонтрагент.Записать();
		
		ЗафиксироватьТранзакцию();
		
	Исключение
        ОписаниеОшибки = ОписаниеОшибки();
		ОтменитьТранзакцию();
	КонецПопытки;

КонецПроцедуры

Процедура ПроцедураСВызовомИсключенияВПопытке()
	Попытка
		ВызватьИсключение "Всё сломалось";
		
	Исключение
		
	КонецПопытки;
КонецПроцедуры
```
* Решение:
    >Добавить проверку состояния транзакции после вызова функции с вызовом исключения в попытке, т.к. из нее не возвращается сообщения об ошибке

    >Нужно проектировать алгоритмы таким образом, чтобы внутри транзакций не было неотловленных ошибок, которые приводят к попытке зафиксировать транзакцию, в которой происходили ошибки. Важно читать те методы, которые мы вызываем при разработке функциональности, чтобы не допустить подобного



### 5. Простой запрос
>Написать запрос для получения остатков &Номенклатура в &Адрес из следующего регистра:
```
РегистрНакопления.Остатки (вид регистра: остатки)
    Измерения: 	Адрес, Номенклатура, Носитель, Резерв, Груз, ЕдиницаУчета, Партия
    Ресурсы: 	Количество
```



### 6. Написать запрос для получения всех записей, сформированных &Регистратор из следующего регистра:
```
РегистрНакопления.ОстаткиНаСкладе (вид регистра: обороты)
    Измерения: 	Адрес, Номенклатура, Носитель, Резерв, Груз, ЕдиницаУчета, Партия
    Ресурсы: 	Количество
```

### 7. Какой из подходов рекомендуется использовать в каких ситуациях?
```
Примеры ситуаций: 
    -Отчет, отображающий текущие остатки,
    -Проверка запрета изменения документа,
    -Обработка загрузки документов типа Регистратор
    -Построение плана инвентаризации недостач/излишков склада по номенклатуре
```


### 8. Написать запрос для получения результата обработки массива заказов по складской операции (список заказов и складская операция заранее известны) из следующего регистра:
```
РегистрНакопления.Заказы (вид регистра: обороты)
    Измерения: СкладскаяОперация, Заказ, Номенклатура, Характеристика, Партия
    Ресурсы: КоличествоПлан, КоличествоФакт

В форматах (отдельно 2 разных запроса):
    -Заказ, ОбработанноеКоличество, Недостача
	-Номенклатура, Характеристика, ОбработанноеКоличество, Недостача
```
